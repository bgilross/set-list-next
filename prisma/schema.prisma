// Prisma schema for Postgres (Supabase or any provider)
// Core entities: Artists, Setlists, Songs, SongRequests
// Generated with support for future tipping & audience sessions.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Non-pooled connection for migrations/introspection
}

// --------------------------------------------------
// ENUMS
// --------------------------------------------------
enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  PLAYED
  CANCELLED
}

// User roles for application authorization
enum UserRole {
  ARTIST
  AUDIENCE
  ADMIN
}

// Sender & message type enums for the messaging system
enum SenderType {
  ARTIST
  AUDIENCE
  SYSTEM
}

enum MessageType {
  TEXT
  ACTION
  TIP
  SYSTEM
}

// --------------------------------------------------
// MODELS
// --------------------------------------------------
model User {
  id          String    @id @default(cuid())
  firebaseUid String    @unique
  displayName String
  photoURL    String?
  role        UserRole  @default(AUDIENCE)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model Artist {
  id           String        @id @default(cuid())
  firebaseUid  String?       @unique
  displayName  String
  slug         String?       @unique
  publicBlurb  String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  setlists     Setlist[]
  songs        Song[]
  requests     SongRequest[]
  events       Event[]
}

model Setlist {
  id         String        @id @default(cuid())
  artist     Artist        @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId   String
  name       String
  isPublic   Boolean       @default(false)
  isActive   Boolean       @default(false)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  songs      SetlistSong[]
  requests   SongRequest[]
  events     Event[]

  @@index([artistId, isActive])
}

model Song {
  id          String        @id @default(cuid())
  artist      Artist        @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId    String
  spotifyId   String?
  name        String
  artistName  String?       // Display artist (cover / original) if differs from owning artist
  album       String?
  year        Int?
  userTags    String[]      @default([])
  notes       String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  setlists    SetlistSong[]
  requests    SongRequest[]

  @@index([artistId])
  @@index([spotifyId])
  @@unique([artistId, spotifyId])
}

// Join table with ordering for songs inside a setlist
model SetlistSong {
  setlist    Setlist @relation(fields: [setlistId], references: [id], onDelete: Cascade)
  setlistId  String
  song       Song    @relation(fields: [songId], references: [id], onDelete: Cascade)
  songId     String
  position   Int

  @@id([setlistId, songId])
  @@index([setlistId, position])
}

model SongRequest {
  id              String        @id @default(cuid())
  artist          Artist        @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId        String
  setlist         Setlist?      @relation(fields: [setlistId], references: [id])
  setlistId       String?
  song            Song?         @relation(fields: [songId], references: [id])
  songId          String?
  rawSongTitle    String?       // Provided when song not in library
  audienceSession String?       // Anonymous session ID
  audienceUserId  String?       // Future auth mapping
  status          RequestStatus @default(PENDING)
  tipCents        Int?          @default(0)
  currency        String?       @default("USD")
  message         String?
  responseMessage String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([artistId, status])
  @@index([createdAt])
}

// Events represent artist sessions (e.g., a gig) where a specific setlist is active
model Event {
  id         String    @id @default(cuid())
  artist     Artist    @relation(fields: [artistId], references: [id], onDelete: Cascade)
  artistId   String
  name       String
  setlist    Setlist?  @relation(fields: [setlistId], references: [id])
  setlistId  String?
  isLive     Boolean   @default(false)
  startsAt   DateTime?
  endsAt     DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  threads    EventThread[]

  @@index([artistId, isLive])
}

// A thread for all messages related to an Event (single chat per event)
model EventThread {
  id        String    @id @default(cuid())
  event     Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  eventId   String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  messages  Message[]
}

model Message {
  id         String      @id @default(cuid())
  thread     EventThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  threadId   String
  senderId   String?     // nullable for system messages
  senderType SenderType
  type       MessageType @default(TEXT)
  content    String?
  meta       Json?
  createdAt  DateTime    @default(now())

  @@index([threadId, createdAt])
}

// --------------------------------------------------
// NOTES
// 1. Enforcing single active setlist per artist: do in application or add DB trigger manually.
// 2. Add foreign key indices automatically handled by Postgres; explicit extra indices included where helpful.
// 3. For large-scale text search, consider pg_trgm & a materialized search column later.
// --------------------------------------------------